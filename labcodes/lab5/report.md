# 练习1

根据注释初始化trapframe的值

1. 
  当一个用户态进程进入RUNNING态后，首先加载新线程的段和CR3，然后调用switch_to函数，保存上下文，将存储相应信息设置为用户态的tf作为参数调用fortret函数，将栈空间切换到新线程的内核栈，加载存储在寄存器中的参数。当所有中断和系统调用返回后，开始执行第一条指令。

# 练习2

首先利用KADDR找到src、dst地址所对应内容，再利用memset完成复制，最后用page_insert来修改页表的对应映射关系，即可复制父进程的内存空间到子进程。

1. 
  实现COW机制，需要在fork进程的时候将父进程的页表设置为只读模式，而不需要在fork的时候将其内存中的内容重新复制一遍。在ucore中，复制mm_struct的工作在dup_mmap中完成。修改dup_mmap，将复制mm_struct改为直接传vma的指针，相当于使两个mm_struct共享原来的内存空间.这样当两个进程读取信息时不会有任何问题。当某个进程需要对页面进行写操作时，由于权限的问题，会触发page fault，然后在do_pgfault函数中可以根据页面的存在情况判断出但前操作是对一个只读页进行写操作，这是就可以根据当前页面的引用情况，取消这个只读的共享设置，并复制一份该页给两个进程分别使用，设置好映射关系这样就可以实现Copy on Write机制。

# 练习3

1. 
  - fork: 创建一个新的进程，父进程复制自己的内存空间给子进程，并将子进程状态设为RUNNABLE。  
  - exec: 将新的程序复制到内核空间并执行（即进入RUNNING态），如果加载失败则调用do_exit退出。  
  - wait: 回收进入僵尸状态的或已终止的子进程的资源，若子进程正在运行，则通过schedule进入SLEEPING状态，SLEEPING时间结束或被唤醒后次再尝试回收。  
  - exit: 回收自身进程的大部分资源并进入僵尸状态，然后查看父进程，如果在SLEEPING状态则唤醒。遍历自己的子进程，将其父进程设置为initproc，如果子进程为僵尸状态且initproc为SLEEPING状态则唤醒initproc。

2. 

```
        fork                wait
UNINIT-------->RUNNABLE------------->SLEEPING
                |      <-------------
        exit    |          wake_up
                |
                v
              ZOMBIE
```

