# 练习1

1. 
  内核信号量结构设计及解释如下：

  ```
  typedef struct {
      int value;                   //信号量，实际含义是剩余资源数
      wait_queue_t wait_queue;     //对应等待队列
  } semaphore_t; 
  ```

  具体使用时，首先调用sem_init对信号量进行初始化。当线程请求资源时，调用down函数（对应P操作），在__down函数中判断value是否大于0，若是则说明有剩余资源，减1后返回；否则说明信号量不够，将其加入等待队列中，调度返回时将其从队列中移除。当线程释放资源时，调用up函数（对应V操作），在__up函数中判断等待队列是否为空，若是则直接将value加1，否则唤醒等待队列中的一个进程。

2. 
  为了在用户态提供信号量机制，由于无法直接调用内核级函数，需要创建新系统调用来实现。可以创建系统调用sys_init、sys_down、sys_up，分别对应信号量初始化、P操作和V操作，在中断处理例程中进行相应的与内核信号量机制相同的实现或者直接调用相应内核级函数即可。

  与为内核级提供信号量机制的相同之处在于初始化、P操作、V操作的具体实现都一样，信号量结构本身也没有变化，不同之处在于不能直接在用户态实现信号量操作，必须通过中断等方式跳转到内核态统一接口进行操作和管理。

# 练习2

在check_sync中，当需要就餐时，将状态设为饥饿，查看左右两边的人是否在就餐，如果不在就餐则占用两边的叉子，否则等待；当开始思考时，将状态设为思考，查看左右两边的人是否处于等待中的饥饿，如果有则唤醒，否则直接释放。两种操作都是对管程进行的，因此都必须事先申请互斥锁，并在结束后释放之。

在monitor.c中，在cond_signal函数中释放叉子，如果等待队列中有等待相应条件变量的进程，则将其唤醒，否则直接释放；在cond_wait中等待叉子，将相应条件变量的等待数加1，加入等待队列中，如果next队列中有等待的进程则优先唤醒，否则让出管程的占用，然后进入等待状态。

1. 
  条件变量和管程的结构及解释如下：

  ```
  typedef struct condvar{
      semaphore_t sem; //信号量及相应等待队列
      int count;   //在该条件变量上等待的进程数
      monitor_t * owner; // the owner(monitor) of this condvar
  } condvar_t;
  ```
  
  ```
  typedef struct monitor{
      semaphore_t mutex;   //互斥锁
      semaphore_t next;     //信号量与相应等待队列
      int next_count;         //等待使用管程的进程数
      condvar_t *cv;      //条件变量
  } monitor_t;
  ```

  执行流程为需要就餐时首先申请mutex进入管程，将状态设为饥饿，查看相邻人的状态，若都不在就餐则占用两边刀叉，否则进入等待状态，释放mutex；思考时同样首先申请mutex进入管程，将状态设为思考，查看相邻人的状态，若有等待则将其唤醒，否则直接释放资源，最后释放mutex退出管程。

2. 
  为了在用户态提供信号量机制，由于无法直接调用内核级函数，需要创建新系统调用来实现。可以创建系统调用sys_init、sys_down、sys_up，分别对应信号量初始化、P操作和V操作，在中断处理例程中进行相应的与内核信号量机制相同的实现或者直接调用相应内核级函数即可。

  与为内核级提供信号量机制的相同之处在于初始化、P操作、V操作的具体实现都一样，信号量结构本身也没有变化，不同之处在于不能直接在用户态实现信号量操作，必须通过中断等方式跳转到内核态统一接口进行操作和管理。
